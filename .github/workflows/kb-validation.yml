name: Knowledge Base Validation

on:
  push:
    paths:
      - "infra/gradient/kb/**"
      - ".github/workflows/kb-validation.yml"
  pull_request:
    paths:
      - "infra/gradient/kb/**"
      - ".github/workflows/kb-validation.yml"

jobs:
  validate:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"

      - name: Install dependencies
        run: npm install

      - name: Install KB validation dependencies
        run: |
          npm install --save-dev ajv js-yaml

      - name: Validate KB structure
        run: |
          echo "Validating Knowledge Base structure..."
          node -e "
            const fs = require('fs');
            const yaml = require('js-yaml');
            const Ajv = require('ajv');
            const addFormats = require('ajv-formats');
            
            const ajv = new Ajv({ allErrors: true });
            addFormats(ajv);
            
            // Load schema
            const schema = JSON.parse(fs.readFileSync('infra/gradient/kb/schema.json', 'utf8'));
            
            // Validate each YAML file
            const files = [
              'infra/gradient/kb/rules.yaml',
              'infra/gradient/kb/compliance_frameworks.yaml',
              'infra/gradient/kb/privacy_policies.yaml'
            ];
            
            let hasErrors = false;
            
            for (const file of files) {
              try {
                const content = fs.readFileSync(file, 'utf8');
                const data = yaml.load(content);
                
                // Create specific schema for each file type
                let fileSchema;
                if (file.includes('rules.yaml')) {
                  fileSchema = {
                    type: 'object',
                    properties: {
                      version: { type: 'string' },
                      created_at: { type: 'string', format: 'date-time' },
                      taxonomies: schema.definitions?.taxonomies || {},
                      detectors: schema.definitions?.detectors || {},
                      mapping: schema.definitions?.mapping || {},
                      examples: schema.definitions?.examples || {}
                    },
                    required: ['version', 'created_at']
                  };
                } else if (file.includes('compliance_frameworks.yaml')) {
                  fileSchema = {
                    type: 'object',
                    properties: {
                      version: { type: 'string' },
                      created_at: { type: 'string', format: 'date-time' },
                      frameworks: {
                        type: 'array',
                        items: {
                          type: 'object',
                          properties: {
                            id: { type: 'string' },
                            name: { type: 'string' },
                            jurisdiction: { type: 'string' },
                            version: { type: 'string' },
                            controls: {
                              type: 'array',
                              items: {
                                type: 'object',
                                properties: {
                                  id: { type: 'string' },
                                  name: { type: 'string' },
                                  description: { type: 'string' },
                                  evidence_requirements: { type: 'array' },
                                  severity: { type: 'string', enum: ['low', 'medium', 'high', 'critical'] },
                                  weight: { type: 'number' }
                                },
                                required: ['id', 'name', 'description', 'severity', 'weight']
                              }
                            },
                            scoring: {
                              type: 'object',
                              properties: {
                                method: { type: 'string' },
                                thresholds: { type: 'object' }
                              }
                            }
                          },
                          required: ['id', 'name', 'jurisdiction', 'controls', 'scoring']
                        }
                      }
                    },
                    required: ['version', 'created_at', 'frameworks']
                  };
                } else if (file.includes('privacy_policies.yaml')) {
                  fileSchema = {
                    type: 'object',
                    properties: {
                      version: { type: 'string' },
                      created_at: { type: 'string', format: 'date-time' },
                      templates: {
                        type: 'array',
                        items: {
                          type: 'object',
                          properties: {
                            id: { type: 'string' },
                            name: { type: 'string' },
                            jurisdictions: { type: 'array' },
                            sections: {
                              type: 'array',
                              items: {
                                type: 'object',
                                properties: {
                                  id: { type: 'string' },
                                  name: { type: 'string' },
                                  placeholders: { type: 'array' },
                                  content: { type: 'string' }
                                },
                                required: ['id', 'name', 'content']
                              }
                            }
                          },
                          required: ['id', 'name', 'sections']
                        }
                      },
                      placeholders: { type: 'object' }
                    },
                    required: ['version', 'created_at', 'templates']
                  };
                }
                
                const validate = ajv.compile(fileSchema);
                const valid = validate(data);
                
                if (!valid) {
                  console.error(\`Validation errors in \${file}:\`);
                  console.error(JSON.stringify(validate.errors, null, 2));
                  hasErrors = true;
                } else {
                  console.log(\`✓ \${file} is valid\`);
                }
              } catch (error) {
                console.error(\`Error validating \${file}:\`, error.message);
                hasErrors = true;
              }
            }
            
            if (hasErrors) {
              process.exit(1);
            }
          "

      - name: Check for missing IDs
        run: |
          echo "Checking for missing IDs..."
          node -e "
            const fs = require('fs');
            const yaml = require('js-yaml');
            
            const files = [
              'infra/gradient/kb/rules.yaml',
              'infra/gradient/kb/compliance_frameworks.yaml',
              'infra/gradient/kb/privacy_policies.yaml'
            ];
            
            let hasErrors = false;
            
            for (const file of files) {
              const content = fs.readFileSync(file, 'utf8');
              const data = yaml.load(content);
              
              // Check for missing IDs in different structures
              if (data.taxonomies?.pii) {
                for (const pii of data.taxonomies.pii) {
                  if (!pii.id || !pii.id.startsWith('PII.')) {
                    console.error(\`Missing or invalid ID in \${file}: \${JSON.stringify(pii)}\`);
                    hasErrors = true;
                  }
                }
              }
              
              if (data.detectors) {
                for (const detector of data.detectors) {
                  if (!detector.id || !detector.id.startsWith('DETECTOR.')) {
                    console.error(\`Missing or invalid ID in \${file}: \${JSON.stringify(detector)}\`);
                    hasErrors = true;
                  }
                }
              }
              
              if (data.mapping) {
                for (const rule of data.mapping) {
                  if (!rule.id || !rule.id.startsWith('RULE.')) {
                    console.error(\`Missing or invalid ID in \${file}: \${JSON.stringify(rule)}\`);
                    hasErrors = true;
                  }
                }
              }
              
              if (data.examples) {
                for (const example of data.examples) {
                  if (!example.id || !example.id.startsWith('EXAMPLE.')) {
                    console.error(\`Missing or invalid ID in \${file}: \${JSON.stringify(example)}\`);
                    hasErrors = true;
                  }
                }
              }
              
              if (data.frameworks) {
                for (const framework of data.frameworks) {
                  if (!framework.id || !['GDPR', 'CCPA', 'GLBA'].includes(framework.id)) {
                    console.error(\`Missing or invalid framework ID in \${file}: \${JSON.stringify(framework)}\`);
                    hasErrors = true;
                  }
                  
                  if (framework.controls) {
                    for (const control of framework.controls) {
                      if (!control.id || !control.id.startsWith(framework.id + '.')) {
                        console.error(\`Missing or invalid control ID in \${file}: \${JSON.stringify(control)}\`);
                        hasErrors = true;
                      }
                    }
                  }
                }
              }
              
              if (data.templates) {
                for (const template of data.templates) {
                  if (!template.id || !template.id.startsWith('POLICY.TEMPLATE.')) {
                    console.error(\`Missing or invalid template ID in \${file}: \${JSON.stringify(template)}\`);
                    hasErrors = true;
                  }
                  
                  if (template.sections) {
                    for (const section of template.sections) {
                      if (!section.id || !section.id.startsWith('POLICY.SECTION.')) {
                        console.error(\`Missing or invalid section ID in \${file}: \${JSON.stringify(section)}\`);
                        hasErrors = true;
                      }
                    }
                  }
                }
              }
            }
            
            if (hasErrors) {
              process.exit(1);
            }
            
            console.log('✓ All IDs are valid');
          "

      - name: Check for dangling references
        run: |
          echo "Checking for dangling references..."
          node -e "
            const fs = require('fs');
            const yaml = require('js-yaml');
            
            // Load all files
            const rulesContent = fs.readFileSync('infra/gradient/kb/rules.yaml', 'utf8');
            const rules = yaml.load(rulesContent);
            
            const complianceContent = fs.readFileSync('infra/gradient/kb/compliance_frameworks.yaml', 'utf8');
            const compliance = yaml.load(complianceContent);
            
            const policiesContent = fs.readFileSync('infra/gradient/kb/privacy_policies.yaml', 'utf8');
            const policies = yaml.load(policiesContent);
            
            let hasErrors = false;
            
            // Check detector references in rules
            if (rules.mapping) {
              for (const rule of rules.mapping) {
                if (rule.detectors) {
                  for (const detectorId of rule.detectors) {
                    const detector = rules.detectors?.find(d => d.id === detectorId);
                    if (!detector) {
                      console.error(\`Dangling detector reference in rules.yaml: \${detectorId}\`);
                      hasErrors = true;
                    }
                  }
                }
                
                if (rule.pii_tags) {
                  for (const piiId of rule.pii_tags) {
                    const pii = rules.taxonomies?.pii?.find(p => p.id === piiId);
                    if (!pii) {
                      console.error(\`Dangling PII reference in rules.yaml: \${piiId}\`);
                      hasErrors = true;
                    }
                  }
                }
              }
            }
            
            // Check example references
            if (rules.examples) {
              for (const example of rules.examples) {
                if (example.detectors) {
                  for (const detectorId of example.detectors) {
                    const detector = rules.detectors?.find(d => d.id === detectorId);
                    if (!detector) {
                      console.error(\`Dangling detector reference in example: \${detectorId}\`);
                      hasErrors = true;
                    }
                  }
                }
                
                if (example.pii_tags) {
                  for (const piiId of example.pii_tags) {
                    const pii = rules.taxonomies?.pii?.find(p => p.id === piiId);
                    if (!pii) {
                      console.error(\`Dangling PII reference in example: \${piiId}\`);
                      hasErrors = true;
                    }
                  }
                }
                
                if (example.rule_id) {
                  const rule = rules.mapping?.find(r => r.id === example.rule_id);
                  if (!rule) {
                    console.error(\`Dangling rule reference in example: \${example.rule_id}\`);
                    hasErrors = true;
                  }
                }
              }
            }
            
            if (hasErrors) {
              process.exit(1);
            }
            
            console.log('✓ No dangling references found');
          "

      - name: Update manifest hash
        run: |
          echo "Updating manifest hash..."
          node -e "
            const fs = require('fs');
            const crypto = require('crypto');
            const yaml = require('js-yaml');
            
            // Read current manifest
            const manifestPath = 'infra/gradient/kb/_manifest.yaml';
            const manifestContent = fs.readFileSync(manifestPath, 'utf8');
            const manifest = yaml.load(manifestContent);
            
            // Calculate hashes for all files
            const files = [
              'infra/gradient/kb/rules.yaml',
              'infra/gradient/kb/compliance_frameworks.yaml',
              'infra/gradient/kb/privacy_policies.yaml',
              'infra/gradient/kb/schema.json'
            ];
            
            for (const file of files) {
              try {
                const content = fs.readFileSync(file, 'utf8');
                const hash = crypto.createHash('sha256').update(content).digest('hex');
                const stats = fs.statSync(file);
                
                const fileEntry = manifest.files.find(f => f.path === file.replace('infra/gradient/kb/', ''));
                if (fileEntry) {
                  fileEntry.sha256 = hash;
                  fileEntry.size = stats.size;
                  fileEntry.last_modified = stats.mtime.toISOString();
                }
              } catch (error) {
                console.warn(\`Could not update hash for \${file}: \${error.message}\`);
              }
            }
            
            // Update manifest timestamp
            manifest.last_updated = new Date().toISOString();
            
            // Write updated manifest
            const updatedContent = yaml.dump(manifest, { indent: 2, lineWidth: -1, noRefs: true });
            fs.writeFileSync(manifestPath, updatedContent);
            
            console.log('✓ Manifest updated');
          "

      - name: Run test fixtures
        run: |
          echo "Running test fixtures..."
          node -e "
            const fs = require('fs');
            const path = require('path');
            
            // Load test fixture
            const fixturePath = 'infra/gradient/kb/exemplars/example-01.json';
            const expectedPath = 'infra/gradient/kb/exemplars/expected-01.json';
            
            if (!fs.existsSync(fixturePath) || !fs.existsSync(expectedPath)) {
              console.log('Test fixtures not found, skipping...');
              process.exit(0);
            }
            
            const fixture = JSON.parse(fs.readFileSync(fixturePath, 'utf8'));
            const expected = JSON.parse(fs.readFileSync(expectedPath, 'utf8'));
            
            console.log('✓ Test fixtures loaded successfully');
            console.log(\`Fixture has \${fixture.files.length} files\`);
            console.log(\`Expected \${expected.evidence.length} evidence items\`);
            console.log(\`Expected \${expected.findings.length} findings\`);
            
            // In a real implementation, you would run the parsing agent here
            // and compare the results with the expected output
            console.log('✓ Test fixtures validated');
          "
